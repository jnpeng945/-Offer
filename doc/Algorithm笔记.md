## 时间、空间复杂度分析

##### 1. 二叉树遍历 - 前序、中序、后序：时间复杂度是多少？

假设二叉树中节点总数为 $n$，时间复杂度为 $O(n)$ 。

- 解释 1：通过主定理得到；

- 解释 2：每种遍历方式中，每个节点仅被访问一次。

##### 2. 图的遍历：时间复杂度？

假设图中的节点总数为 $n$ ，图中每个节点仅被访问一次。

##### 3. DFS，BFS 时间复杂度？

假设搜索空间中的节点数为 $n$，时间复杂度为 $O(n)$，每个节点仅被访问一次。

##### 4. 二分查找时间复杂度？

$O(logn)$



> 知乎：各种时间空间复杂度分析[原文地址](http://www.zhihu.com/question/21387264)
>
> 维基百科：主定理 [原文地址]([Master theorem (analysis of algorithms) - Wikipedia](https://en.wikipedia.org/wiki/Master_theorem_(analysis_of_algorithms)))



## 数组、链表、栈和队列

`vector` 数组实现：

- 初始：空数组，分配常数空间；
- `push_back()` ：若空间不够，重新申请 $2$ 倍大小的连续空间，拷贝到新空间，释放旧空间；
- `pop_back()` ：若空间利用率不到 $25\%$ ，释放一半的空间；

均摊 $O(1)$ 

在空数组中连续插入 $n$ 个元素，总插入 / 拷贝次数为 $n+\frac{n}{2}+\frac{n}{4}+\frac{n}{8}... < 2n$ 

一次扩容到下次释放，至少需要再删除 $(1-2\times0.25)*n=0.5n$ 次



## 双指针扫描

用于解决一类**基于 "子段" 的统计问题**

子段：数组中连续的一段（下标范围可以用一个闭区间来表示）



这类题目的朴素做法都是两重循环的枚举，枚举左端点 $l$ 、右端点 $r$ （$l \leq r$） 

优化手段都是找到枚举中的冗余部分，将其去除。



**优化策略：**

- 固定右端点，看左端点的取值范围
  - 例如左端点的取值范围是一个前缀，可以用 “前缀和“ 等算法维护前缀信息
- 移动一个端点，看另一个端点的变化情况
  - 例如一个端点跟随另一个端点单调移动，”滑动窗口“
  - ”双指针扫描“












